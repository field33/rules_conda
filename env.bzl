load(":utils.bzl", "CONDA_EXT_MAP", "EXECUTE_TIMEOUT", "PYTHON_EXT_MAP", "get_os")

BUILD_FILE_CONTENT = """# This file was automatically generated by rules_conda
package(default_visibility = ["//visibility:public"])

load("@bazel_tools//tools/python:toolchain.bzl", "py_runtime_pair")

py_runtime(
    name = "python_runtime",
    files = glob(["{env_path}/**/*"], exclude_directories = 0),
    interpreter = "{env_path}/{interpreter_path}",
    python_version = "PY{py_major}"
)
"""

def _label_from_condabin(rctx, exe_name):
    return Label("@{}//:{}/condabin/{}{}".format(
        rctx.attr.conda_repo,
        rctx.attr.conda_dir,
        exe_name,
        CONDA_EXT_MAP[get_os(rctx)],
    ))

def _user_chosen_executable(rctx):
    if rctx.attr.use_mamba:
        return _label_from_condabin(rctx, "mamba")
    return _label_from_condabin(rctx, "conda")

# clean conda caches and unused packages
def _clean(rctx, executable):
    rctx.report_progress("Cleaning up")

    args = [executable, "clean", "-a", "-y"]

    result = rctx.execute(args, quiet = rctx.attr.quiet, timeout = rctx.attr.timeout)
    if result.return_code:
        fail("Failure cleaning up.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

def _create_empty_environment(rctx, executable, env_name):
    rctx.report_progress("Creating empty conda environment, to be populated afterwards")
    args = [executable, "create", "-y", "-p", "./{}".format(env_name)]
    result = rctx.execute(args, quiet = rctx.attr.quiet, timeout = rctx.attr.timeout)
    if result.return_code:
        fail("Failure creating empty environment.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

def _create_environment_from_lockfile(rctx, executable, env_name, lock_file):
    rctx.report_progress("Creating environment from conda-lock lockfile")
    args = ["conda-lock", "install", "-p", "./{}".format(env_name), lock_file ]
    result = rctx.execute(args, quiet = rctx.attr.quiet, timeout = rctx.attr.timeout)
    if result.return_code:
        fail("Failure creating environment from lockfile environment.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

def _update_environment(rctx, executable, env_name, env_file):
    rctx.report_progress("Updating empty conda environment to populate it")
    args = [executable, "env", "update", "-f", env_file, "-p", "./{}".format(env_name)]
    result = rctx.execute(args, quiet = rctx.attr.quiet, timeout = rctx.attr.timeout)
    if result.return_code:
        fail("Failure updating environment.\nstdout: {}\nstderr: {}".format(result.stdout, result.stderr))

# create new local conda environment from file
def _create_environment(rctx, executable, env_name, is_lockfile):
    rctx.report_progress("Creating conda environment")

    # path to env file as string
    env_file = rctx.path(rctx.attr.environment)

    if is_lockfile:
        _create_environment_from_lockfile(rctx, executable, env_name, env_file)
    else:
        _create_empty_environment(rctx, executable, env_name)
        _update_environment(rctx, executable, env_name, env_file)

# check if python2 or python3 has been installed
def _get_py_major(rctx, env_path, interpreter_path):
    interpreter = "{}/{}".format(env_path, interpreter_path)
    result = rctx.execute([rctx.path(interpreter), "--version"], timeout = rctx.attr.timeout)
    output = result.stdout if result.stdout else result.stderr
    return int(output.replace("Python ", "").partition(".")[0])

# create BUILD file with py_runtime
def _create_env_build_file(rctx, env_name):
    os = get_os(rctx)
    python_executable = "python{}".format(PYTHON_EXT_MAP[os])
    interpreter_path = python_executable if os == "Windows" else "bin/{}".format(python_executable)
    py_major = _get_py_major(rctx, env_name, interpreter_path)
    rctx.file(
        "BUILD",
        content = BUILD_FILE_CONTENT.format(
            env_path = env_name,
            interpreter_path = interpreter_path,
            py_major = py_major,
        ),
    )

def _conda_create_impl(rctx):
    executable = _user_chosen_executable(rctx)
    env_name = rctx.name
    _create_environment(rctx, executable, env_name, rctx.attr.is_lockfile)
    if rctx.attr.clean:
        _clean(rctx, executable)
    _create_env_build_file(rctx, env_name)

conda_create_rule = repository_rule(
    _conda_create_impl,
    attrs = {
        "conda_repo": attr.string(mandatory = True),
        "conda_dir": attr.string(mandatory = True),
        "environment": attr.label(
            mandatory = True,
            allow_single_file = True,
            doc = "The label of the environment.yml file.",
        ),
        "quiet": attr.bool(
            default = True,
            doc = "False if conda output should be shown",
        ),
        "use_mamba": attr.bool(
            default = False,
            doc = "True if mamba should be used",
        ),
        "timeout": attr.int(
            default = EXECUTE_TIMEOUT,
            doc = "Timeout in seconds for each execute action",
        ),
        "clean": attr.bool(
            default = False,
            doc = "True if conda cache should be cleaned",
        ),
        "is_lockfile": attr.bool(
            default = False,
            doc = "True if installing from a lockfile generated via conda-lock",
        ),
    },
)
